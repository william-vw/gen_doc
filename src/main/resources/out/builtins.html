<html><head><link href='style.css' rel='stylesheet' /></head><body><div><h2>math</h2>(http://www.w3.org/2000/10/swap/math#)<div><h4>math:absoluteValue</h4>(http://www.w3.org/2000/10/swap/math#absoluteValue)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable</p><h5>comment</h5><p>The object is calulated as the absolute value of the subject.</p></div><div><h4>math:acos</h4>(http://www.w3.org/2000/10/swap/math#acos)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The object is calulated as the arc cosine value of the subject.</p></div><div><h4>math:acosh</h4>(http://www.w3.org/2000/10/swap/math#acosh)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p></div><div><h4>math:asin</h4>(http://www.w3.org/2000/10/swap/math#asin)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The object is calulated as the arc sine value of the subject.</p></div><div><h4>math:asinh</h4>(http://www.w3.org/2000/10/swap/math#asinh)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p></div><div><h4>math:atan</h4>(http://www.w3.org/2000/10/swap/math#atan)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The object is calulated as the arc tangent value of the subject.</p></div><div><h4>math:atanh</h4>(http://www.w3.org/2000/10/swap/math#atanh)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p></div><div><h4>math:ceiling</h4>(http://www.w3.org/2000/10/swap/math#ceiling)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable</p></div><div><h4>math:cos</h4>(http://www.w3.org/2000/10/swap/math#cos)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The subject is an angle expressed in radians.
The object is calulated as the cosine value of the subject.</p></div><div><h4>math:cosh</h4>(http://www.w3.org/2000/10/swap/math#cosh)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The subject is an angle expressed in radians.
The object is calulated as the #hyperbolic cosine value of the subject.</p></div><div><h4>math:degrees</h4>(http://www.w3.org/2000/10/swap/math#degrees)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The subject is an angle expressed in radians.
The object is calulated as the conversion in degrees of the value of the subject.</p></div><div><h4>math:difference</h4>(http://www.w3.org/2000/10/swap/math#difference)<h5>schema</h5><p>subject: ($s1 $s_2) where $s_i is numberable OR variable<br />object: $o is numberable OR variable</p><h5>comment</h5><p>The subject is a pair of numbers. The object
is calculated by subtracting the second number of the pair from the first.
</p></div><div><h4>math:equalTo</h4>(http://www.w3.org/2000/10/swap/math#equalTo)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable</p><h5>comment</h5><p>Checks equality of numbers.
   
`true` if and only if `$s` is equal to `$o`.</p></div><div><h4>math:exponentiation</h4>(http://www.w3.org/2000/10/swap/math#exponentiation)<h5>schema</h5><p>subject: ($s1 $s_2) where $s_i is numberable OR variable<br />object: $o is numberable OR variable</p><h5>comment</h5><p>The subject is a pair of numbers. The object
is calculated by raising the first number of the power of the second.
</p></div><div><h4>math:floor</h4>(http://www.w3.org/2000/10/swap/math#floor)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable</p></div><div><h4>math:greaterThan</h4>(http://www.w3.org/2000/10/swap/math#greaterThan)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable</p><h5>comment</h5><p>`true` if and only if the subject is a number which is greater than the object.</p></div><div><h4>math:lessThan</h4>(http://www.w3.org/2000/10/swap/math#lessThan)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable</p><h5>comment</h5><p>`true` if and only if the subject is a number which is LESS than a object.</p></div><div><h4>math:logarithm</h4>(http://www.w3.org/2000/10/swap/math#logarithm)<h5>schema</h5><p>subject: ($s1 $s_2) where $s_i is numberable OR variable<br />object: $o is numberable OR variable</p></div><div><h4>math:max</h4>(http://www.w3.org/2000/10/swap/math#max)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is numberable<br />object: $o is numberable OR variable</p></div><div><h4>math:min</h4>(http://www.w3.org/2000/10/swap/math#min)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is numberable<br />object: $o is numberable OR variable</p></div><div><h4>math:negation</h4>(http://www.w3.org/2000/10/swap/math#negation)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The subject or object is calculated to be the negation of the other.</p></div><div><h4>math:notEqualTo</h4>(http://www.w3.org/2000/10/swap/math#notEqualTo)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable</p><h5>comment</h5><p>`true` if and only if the subject is a number which is NOT EQUAL to a object.</p></div><div><h4>math:notGreaterThan</h4>(http://www.w3.org/2000/10/swap/math#notGreaterThan)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable</p><h5>comment</h5><p>`true` if and only if the subject is a number which is NOT greater than the object.</p></div><div><h4>math:notLessThan</h4>(http://www.w3.org/2000/10/swap/math#notLessThan)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable</p><h5>comment</h5><p>`true` if and only if the subject is a number which is NOT LESS than a object.</p></div><div><h4>math:product</h4>(http://www.w3.org/2000/10/swap/math#product)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is numberable<br />object: $o is numberable OR variable</p><h5>comment</h5><p>The subject is a list of numbers.
The object is calculated as the arithmentic product of those numbers.
</p></div><div><h4>math:quotient</h4>(http://www.w3.org/2000/10/swap/math#quotient)<h5>schema</h5><p>subject: ($s1 $s_2) where $s_i is numberable OR variable<br />object: $o is numberable OR variable</p><h5>comment</h5><p>The subject is a pair of numbers. The object
is calculated by dividing the first number of the pair by the second.
</p></div><div><h4>math:radians</h4>(http://www.w3.org/2000/10/swap/math#radians)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p></div><div><h4>math:remainder</h4>(http://www.w3.org/2000/10/swap/math#remainder)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is intable, $s_1 is intable<br />object: $o is intable OR variable</p><h5>comment</h5><p>The subject is a pair of integers. The object
is calculated by dividing the first number of the pair by the second and taking the remainder.
</p></div><div><h4>math:rounded</h4>(http://www.w3.org/2000/10/swap/math#rounded)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable</p><h5>comment</h5><p>The object is calulated as the number with no fractional part that is closest to the subject.
If there are two such numbers, then the one that is closest to positive infinity is returned.
</p></div><div><h4>math:roundedTo</h4>(http://www.w3.org/2000/10/swap/math#roundedTo)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is numberable, $s_1 is intable<br />object: $o is numberable OR variable</p></div><div><h4>math:sin</h4>(http://www.w3.org/2000/10/swap/math#sin)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The subject is an angle expressed in radians.
The object is calulated as the sine value of the subject.</p></div><div><h4>math:sinh</h4>(http://www.w3.org/2000/10/swap/math#sinh)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The subject is an angle expressed in radians.
The object is calulated as the hyperbolic sine value of the subject.</p></div><div><h4>math:sum</h4>(http://www.w3.org/2000/10/swap/math#sum)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is numberable<br />object: $o is numberable OR variable</p><h5>comment</h5><p>Performs addition of numbers. <br />`true` if and only if the arithmetic sum of `$s_1, .. $s_n` equals `$o`.</p></div><div><h4>math:tan</h4>(http://www.w3.org/2000/10/swap/math#tan)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The subject is an angle expressed in radians.
The object is calulated as the tangent value of the subject.</p></div><div><h4>math:tanh</h4>(http://www.w3.org/2000/10/swap/math#tanh)<h5>schema</h5><p>subject: $s is numberable<br />object: $o is numberable OR variable<br />OR<br />subject: $s is numberable OR variable<br />object: $o is numberable</p><h5>comment</h5><p>The subject is an angle expressed in radians.
The object is calulated as the hyperbolic tangent value of the subject.</p></div></div><div><h2>list</h2>(http://www.w3.org/2000/10/swap/list#)<div><h4>list:append</h4>(http://www.w3.org/2000/10/swap/list#append)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is list<br />object: $o is list OR variable</p><h5>comment</h5><p>Concatenates separate lists into a single list. <br />`true` if and only if the subject is a list of lists and the concatenation of all those lists is `$o`.<br />`$o` can be calculated as a function of the subject. <br />Example: `( (1 2) (3 4) ) list:append (1 2 3 4).`</p></div><div><h4>list:first</h4>(http://www.w3.org/2000/10/swap/list#first)<h5>schema</h5><p>subject: $s is list<br />object: $o is any</p><h5>comment</h5><p>Extracts the first member of a list. <br />`true` if and only the subject is a list and `$o` is the first member of that list.<br />`$o` can be calculated as a function of the subject.</p></div><div><h4>list:in</h4>(http://www.w3.org/2000/10/swap/list#in)<h5>schema</h5><p>subject: $s is any<br />object: $o is list</p><h5>comment</h5><p>Determines if an subject is a member of the object list or binds every member of the object list to the subject.<br />`true` if and only `$o` is a list and `$s` is in that list.<br />`$s` can be calculated from `$o`.</p></div><div><h4>list:iterate</h4>(http://www.w3.org/2000/10/swap/list#iterate)<h5>schema</h5><p>subject: $s is list<br />object: $o is variable</p><h5>comment</h5><p>Iterates over index/value pairs of the subject list.
Gets the matching pair of list index and list value for every member of the subject.
If the object is a variable, it will create a solution for each member of the subject list.
If any member of the object list is a variable, it will create a solution for all matching
members of the subject list.<br />If the object is ground and the entry at the specified index matches the specified value, 
it evaluates to `true`; otherwise, `false`.<br />Example: `( 1 2 3 ) list:iterate ($i $v).`</p></div><div><h4>list:last</h4>(http://www.w3.org/2000/10/swap/list#last)<h5>schema</h5><p>subject: $s is list<br />object: $o is any</p><h5>comment</h5><p>Extracts the first member of a list. <br />`true` if and only the subject is a list and `$o` is the last member of that list.<br />`$o` can be calculated as a function of the subject.</p></div><div><h4>list:length</h4>(http://www.w3.org/2000/10/swap/list#length)<h5>schema</h5><p>subject: $s is list<br />object: $o is intable OR variable</p><h5>comment</h5><p>Calculates the length of a list.<br />`true` if and only the subject is a list and `$o` is integer length of that list.<br />`$o` can be calculated as a function of the subject.</p></div><div><h4>list:member</h4>(http://www.w3.org/2000/10/swap/list#member)<h5>schema</h5><p>subject: $s is list<br />object: $o is any</p><h5>comment</h5><p>Determines if an object is a member of the subject list or binds every member of the subject list to the object.<br />`true` if and only `$s` is a list and `o` is in that list.<br />`$o` can be calculated from `$s`.</p></div><div><h4>list:memberAt</h4>(http://www.w3.org/2000/10/swap/list#memberAt)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is list, $s_1 is intable<br />object: $o is any</p><h5>comment</h5><p>Gets the member of a list at a given position (where the position of the first element is 1).<br />`true` if and only if `$s_0` has an element at position `$s_1`, and if that element and `$o` can unify.<br />Note that if `$s_1` is a variable, this builtin may bind it to more than one value (e.g. `((“A” “B” “A”) ?i) list:memberAt \"A\"`).<br />In case of a negative integer, the index will count backwards from the length of the list.</p></div><div><h4>list:notIn</h4>(http://www.w3.org/2000/10/swap/list#notIn)<h5>schema</h5><p>subject: $s is concrete<br />object: ($o_1 .. $o_n) where $o_i is concrete</p></div><div><h4>list:notMember</h4>(http://www.w3.org/2000/10/swap/list#notMember)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is concrete<br />object: $o is concrete</p></div><div><h4>list:remove</h4>(http://www.w3.org/2000/10/swap/list#remove)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is list, $s_1 is concrete<br />object: $o is list OR variable</p><h5>comment</h5><p>Removes the second component of the subject list from the first component of that list.<br />`true` if and only if the subject is a list of two lists `$s_1` and `$s_2`, `$s_2` is a subset of `$s_1` and `$o` is a list composed of the members of the `$s_1` with all members of `$s_2` removed, matching left to right.<br />`$o` can be calculated as a function of the subject.<br />Example: `( (1 2 3 4) (2 3) ) list:remove (1 4).`</p></div><div><h4>list:removeAt</h4>(http://www.w3.org/2000/10/swap/list#removeAt)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is list, $s_1 is intable<br />object: $o is list OR variable</p></div><div><h4>list:removeDuplicates</h4>(http://www.w3.org/2000/10/swap/list#removeDuplicates)<h5>schema</h5><p>subject: $s is list<br />object: $o is list OR variable</p></div><div><h4>list:sort</h4>(http://www.w3.org/2000/10/swap/list#sort)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is concrete<br />object: $o is variable</p></div><div><h4>list:unique</h4>(http://www.w3.org/2000/10/swap/list#unique)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is concrete<br />object: $o is list OR variable</p></div></div><div><h2>log</h2>(http://www.w3.org/2000/10/swap/log#)<div><h4>log:bound</h4>(http://www.w3.org/2000/10/swap/log#bound)<h5>schema</h5><p>subject: $s is any<br />object: $o is xsd:boolean OR variable</p></div><div><h4>log:collectAllIn</h4>(http://www.w3.org/2000/10/swap/log#collectAllIn)<h5>schema</h5><p>subject: ($s_0 $s_1 $s_2) where $s_0 is variable, $s_1 is formula, $s_2 is list OR variable<br />object: $o is baseIri OR formula OR variable</p></div><div><h4>log:conclusion</h4>(http://www.w3.org/2000/10/swap/log#conclusion)<h5>schema</h5><p>subject: $s is formula<br />object: $o is formula OR variable</p><h5>comment</h5><p>All possible conclusions which can be drawn from a formula.<br />`true` if and only if `$o` is the set of conclusions which can be drawn from `$s`, by successively applying any rules it contains to the data it contains.
Note: this is equivalent to cwm's \"--think\" command line function. It does use built-ins, so it may for example indirectly invoke other documents, validate signatures, etc.</p></div><div><h4>log:conjunction</h4>(http://www.w3.org/2000/10/swap/log#conjunction)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is formula<br />object: $o is formula OR variable</p><h5>comment</h5><p>A function to merge formulae: logical AND.<br />`true` if and only if `o`, which can be generated, is a formula containing a copy of each of the formulae `$s_1 .. $s_n`.</p></div><div><h4>log:content</h4>(http://www.w3.org/2000/10/swap/log#content)<h5>schema</h5><p>subject: $s is iri<br />object: $o is stringable OR variable</p><h5>comment</h5><p>This connects a document and a string that represents it. (Cwm knows how to go get a document in order to evaluate this.)
Note: the content-type of the information is not given and so must be known or guessed.</p></div><div><h4>log:dtlit</h4>(http://www.w3.org/2000/10/swap/log#dtlit)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is stringable, $s_1 is iri<br />object: $o is literal OR variable<br />OR<br />subject: ($s_0 $s_1) where $s_0 is variable, $s_1 is variable<br />object: $o is literal<br />OR<br />subject: $s is variable<br />object: $o is literal</p><h5>comment</h5><p>Takes a list of a string and an IRI and creates a datatyped literal.
The subject is a list composed of a string and an IRI, and the object is a datatyped literal with the value `$s_1` and datatype `$s_2`.<br />`true` if and only if the datatyped literal formed of `$s_0` and `$s_1` equals `$o`.<br />Example: ``{ (\"2005-03-30T11:00:00\" xsd:dateTime) log:dtlit ?X } => { ?X a :Answer } .` will produce `\"2005-03-30T11:00:00\"^^xsd:dateTime a :Answer .`</p></div><div><h4>log:equalTo</h4>(http://www.w3.org/2000/10/swap/log#equalTo)<h5>schema</h5><p>subject: $s is concrete<br />object: $o is any<br />OR<br />subject: $s is any<br />object: $o is concrete</p><h5>comment</h5><p>Determines if two RDF resources are the same.<br />`true` if and only if `$s` and `$o` are the same RDF node (symbol or literal).<br />Not to be confused with owl:sameAs.</p></div><div><h4>log:forAllIn</h4>(http://www.w3.org/2000/10/swap/log#forAllIn)<h5>schema</h5><p>subject: ($s1 $s_2) where $s_i is formula<br />object: $o is baseIri OR formula OR variable</p><h5>comment</h5><p>Built-in for implementing a scoped universal quantification.</p></div><div><h4>log:hasPrefix</h4>(http://www.w3.org/2000/10/swap/log#hasPrefix)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is xsd:boolean OR variable</p></div><div><h4>log:includes</h4>(http://www.w3.org/2000/10/swap/log#includes)<h5>schema</h5><p>subject: $s is formula OR baseIri<br />object: $o is formula OR variable OR baseIri</p><h5>comment</h5><p>The subject formula includes the object formula.<br />`true` if and only if `s` includes `$o` if there exists some substitution which when applied to `$o` creates a formula B' such that for every statement in B' is also in `$s`, every variable universally (or existentially) quantified in B' is quantified in the same way in `$s`. <br />Variable substitution is applied recursively to nested compound terms such as formulae, lists and sets.<br />Note: you can use this to peer inside nested formulae.</p></div><div><h4>log:inferences</h4>(http://www.w3.org/2000/10/swap/log#inferences)<h5>schema</h5><p>subject: $s is formula<br />object: $o is formula OR variable</p></div><div><h4>log:langlit</h4>(http://www.w3.org/2000/10/swap/log#langlit)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is stringable, $s_1 is stringable<br />object: $o is literal OR variable<br />OR<br />subject: ($s_0 $s_1) where $s_0 is variable, $s_1 is variable<br />object: $o is literal<br />OR<br />subject: $s is variable<br />object: $o is literal</p><h5>comment</h5><p>Takes a list of two strings and creates a language-tagged literal.
The subject is a list composed of two strings, and the object is a language-tagged literal with the value `$s_1` and language `$s_2`.<br />`true` if and only if the language-tagged literal formed of `$s_1` and `$s_2` equals `$s_3`.<br />`$s_2` should be a string in the form of a [BCP47](https://tools.ietf.org/html/bcp47) language tag.<br />Example: `{ (\"hello\" \"en\") log:langlit ?X } => { ?X a :Answer } .` will produce `\"hello\"^^en a :Answer .`</p></div><div><h4>log:localName</h4>(http://www.w3.org/2000/10/swap/log#localName)<h5>schema</h5><p>subject: $s is iri<br />object: $o is stringable OR variable</p></div><div><h4>log:nameSpace</h4>(http://www.w3.org/2000/10/swap/log#nameSpace)<h5>schema</h5><p>subject: $s is iri<br />object: $o is stringable OR variable</p></div><div><h4>log:notEqualTo</h4>(http://www.w3.org/2000/10/swap/log#notEqualTo)<h5>schema</h5><p>subject: $s is concrete<br />object: $o is concrete</p><h5>comment</h5><p>Determines if two RDF resources are not the same.<br />`true` if and only if `$s` and `$o` are not the same RDF node (symbol or literal).</p></div><div><h4>log:notIncludes</h4>(http://www.w3.org/2000/10/swap/log#notIncludes)<h5>schema</h5><p>subject: $s is formula OR baseIri<br />object: $o is formula OR variable OR baseIri</p><h5>comment</h5><p>The object formula is NOT a subset of subject.<br />`true` if and only if `log:includes` is `false`. The converse of log:includes.<br />Related: see `log:includes`.</p></div><div><h4>log:outputString</h4>(http://www.w3.org/2000/10/swap/log#outputString)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>The subject is a key and the object is a string,
where the strings are to be output in the order of the keys.
See cwm --strings in cwm --help.
</p></div><div><h4>log:parsedAsN3</h4>(http://www.w3.org/2000/10/swap/log#parsedAsN3)<h5>schema</h5><p>subject: $s is string<br />object: $o is formula OR variable<br />OR<br />subject: $s is variable<br />object: $o is formula</p><h5>comment</h5><p>The subject string, parsed as N3, gives this formula.<br />`true` if and only if `$s`, parsed as N3, gives `$o`.<br />`$s` should be a syntactically valid string in N3 format.<br />Related: see `log:n3String`.</p></div><div><h4>log:prefix</h4>(http://www.w3.org/2000/10/swap/log#prefix)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable OR variable<br />OR<br />subject: $s is variable<br />object: $o is stringable</p></div><div><h4>log:rawType</h4>(http://www.w3.org/2000/10/swap/log#rawType)<h5>schema</h5><p>subject: $s is concrete<br />object: $o is iri OR variable</p><h5>comment</h5><p>Returns an identifier based on the type of the RDF Resource.<br />`true` if the type of `$s` is the same as `$o`, or binds the type to `$o`.<br />`$o` is unbound or one of `log:Formula`, `log:Literal`, `log:List`, `log:Set` or `log:Other`.<br />Example: `log:semanticsOrError` returns either a formula or a string, and you can check which using `log:rawType`. </p></div><div><h4>log:semantics</h4>(http://www.w3.org/2000/10/swap/log#semantics)<h5>schema</h5><p>subject: $s is iri<br />object: $o is formula OR variable</p><h5>comment</h5><p>The log:semantics of a document is the formula achieved by parsing representation of the document.
For a document in Notation3, `log:semantics` is the `log:parsedAsN3` of the `log:content` of the document.
For a document in another RDF syntax, it is parsed according to the appropriate specification to yield an RDF formula (a subclass of N3 `log:Formula`).
Evaluates to `false` if an unrecognized document format is retrieved.
Aside: Philosophers will be distracted here into worrying about the meaning of meaning. At least we didn't call this function \"meaning\"! 
In as much as N3 is used as an interlingua for interoperability for different systems, this for an N3 based system is the meaning expressed by a document.
Related: see `log:parsedAsN3` and `log:content`.</p></div><div><h4>log:semanticsOrError</h4>(http://www.w3.org/2000/10/swap/log#semanticsOrError)<h5>schema</h5><p>subject: $s is iri<br />object: $o is formula OR literal OR variable</p><h5>comment</h5><p>This connects a document and either the formula it parses to, or an error message explaining what went wrong with trying.
Related: see `log:semantics`.</p></div><div><h4>log:skolem</h4>(http://www.w3.org/2000/10/swap/log#skolem)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is concrete<br />object: $o is any</p><h5>comment</h5><p>Built-in to generate a Skolem IRI object which is a function of the arguments in the subject list</p></div><div><h4>log:uri</h4>(http://www.w3.org/2000/10/swap/log#uri)<h5>schema</h5><p>subject: $s is iri<br />object: $o is stringable OR variable<br />OR<br />subject: $s is variable<br />object: $o is stringable</p><h5>comment</h5><p>This allows one to look at the actual string of the URI which identifies this.<br />(Cwm can get the URI of a resource or get the resource from the URI.)
This is a level breaker, breaking the rule of not looking inside a
URI.   Use (eg with  string:match) to replace RDF's old \"aboutEach\"
functionality. Use to implement the URI spec and protocol specs, etc.
</p></div><div><h4>log:uuid</h4>(http://www.w3.org/2000/10/swap/log#uuid)<h5>schema</h5><p>subject: $s is any<br />object: $o is string OR variable</p></div></div><div><h2>time</h2>(http://www.w3.org/2000/10/swap/time#)<div><h4>time:currentTime</h4>(http://www.w3.org/2000/10/swap/time#currentTime)<h5>schema</h5><p>subject: $s is baseIri<br />object: $o is xsd:dateTime OR variable</p></div><div><h4>time:day</h4>(http://www.w3.org/2000/10/swap/time#day)<h5>schema</h5><p>subject: $s is xsd:dateTime OR xsd:date<br />object: $o is intable OR variable</p><h5>comment</h5><p>
`true` if and only if $s is a `xsd:dateTime` and $o is the integer day component of the dateTime.<br />$o can be calculated as a function of $s.
</p></div><div><h4>time:dayOfWeek</h4>(http://www.w3.org/2000/10/swap/time#dayOfWeek)<h5>schema</h5><p>subject: $s is xsd:dateTime OR xsd:date<br />object: $o is intable OR variable</p><h5>comment</h5><p>
`true` if and only if $s is a `xsd:dateTime` and $o is the integer the day number within the week, Sunday being 0.<br />$o can be calculated as a function of $s.
</p></div><div><h4>time:hour</h4>(http://www.w3.org/2000/10/swap/time#hour)<h5>schema</h5><p>subject: $s is xsd:dateTime OR xsd:time<br />object: $o is intable OR variable</p><h5>comment</h5><p>
`true` if and only if $s is a `xsd:dateTime` and $o is the integer hours component of the dateTime.<br />$o can be calculated as a function of $s.
</p></div><div><h4>time:inSeconds</h4>(http://www.w3.org/2000/10/swap/time#inSeconds)<h5>schema</h5><p>subject: $s is xsd:dateTime<br />object: $o is intable OR variable<br />OR<br />subject: $s is variable<br />object: $o is intable</p><h5>comment</h5><p>
`true` if and only if the $s is a `xsd:dateTime` and the $o is the integer number of seconds
since the beginning of the era on a given system.  Don't assume a particular value, always test for it.<br />$o can be calculated as a function of $s.<br />Cwm implements this as a bidirectional function: you can calculate the
ISO date from the seconds since the beginning of the era, or vice-versa.
</p></div><div><h4>time:minute</h4>(http://www.w3.org/2000/10/swap/time#minute)<h5>schema</h5><p>subject: $s is xsd:dateTime OR xsd:time<br />object: $o is intable OR variable</p><h5>comment</h5><p>
`true` if and only if $s is a `xsd:dateTime` and $o is the integer minutes component of the dateTime.<br />$o can be calculated as a function of $s.
</p></div><div><h4>time:month</h4>(http://www.w3.org/2000/10/swap/time#month)<h5>schema</h5><p>subject: $s is xsd:dateTime OR xsd:date<br />object: $o is intable OR variable</p><h5>comment</h5><p>
`true` if and only if $s is a `xsd:dateTime` and $o is the integer month component of the dateTime.<br />$o can be calculated as a function of $s.
</p></div><div><h4>time:second</h4>(http://www.w3.org/2000/10/swap/time#second)<h5>schema</h5><p>subject: $s is xsd:dateTime OR xsd:time<br />object: $o is intable OR variable</p><h5>comment</h5><p>
`true` if and only if $s is a `xsd:dateTime` and $o is the integer seconds component of the dateTime.<br />$o can be calculated as a function of $s.
</p></div><div><h4>time:timeZone</h4>(http://www.w3.org/2000/10/swap/time#timeZone)<h5>schema</h5><p>subject: $s is xsd:dateTime OR xsd:date OR xsd:time<br />object: $o is intable OR variable</p><h5>comment</h5><p>
`true` if and only if $s is a `xsd:dateTime` and $o is the trailing timezone offset
part, e.g.  \"-05:00\"..<br />$o can be calculated as a function of $s.
</p></div><div><h4>time:year</h4>(http://www.w3.org/2000/10/swap/time#year)<h5>schema</h5><p>subject: $s is xsd:dateTime OR xsd:date<br />object: $o is intable OR variable</p><h5>comment</h5><p>
`true` if and only if $s is a `xsd:dateTime` and $o is the integer year component of the dateTime.<br />$o can be calculated as a function of $s.
</p></div></div><div><h2>string</h2>(http://www.w3.org/2000/10/swap/string#)<div><h4>string:capitalize</h4>(http://www.w3.org/2000/10/swap/string#capitalize)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable OR variable</p></div><div><h4>string:concatenation</h4>(http://www.w3.org/2000/10/swap/string#concatenation)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is stringable<br />object: $o is stringable OR variable</p><h5>comment</h5><p>Concatenates the given strings. 
    
`true` if and only if the string concatenation of `$s_1, .. $s_n` equals `$o`.</p></div><div><h4>string:contains</h4>(http://www.w3.org/2000/10/swap/string#contains)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the subject string contains the object string.</p></div><div><h4>string:containsIgnoringCase</h4>(http://www.w3.org/2000/10/swap/string#containsIgnoringCase)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the subject string contains the object string,
with the comparison done ignoring the difference between upper case and
lower case characters.</p></div><div><h4>string:containsRoughly</h4>(http://www.w3.org/2000/10/swap/string#containsRoughly)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p></div><div><h4>string:endsWith</h4>(http://www.w3.org/2000/10/swap/string#endsWith)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the subject string ends with the object string.</p></div><div><h4>string:equalIgnoringCase</h4>(http://www.w3.org/2000/10/swap/string#equalIgnoringCase)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the subject string is the same as object string
ignoring differences between upper and lower case.</p></div><div><h4>string:format</h4>(http://www.w3.org/2000/10/swap/string#format)<h5>schema</h5><p>subject: ($s_1 .. $s_n) where $s_i is stringable<br />object: $o is stringable OR variable</p><h5>comment</h5><p>The subject is a list, whose first member is a format string,
and whose remaining members are arguments to the format string.
The formating string is in the style of python's % operator,
very similar to C's sprintf().
The object is calculated from the subject.</p></div><div><h4>string:greaterThan</h4>(http://www.w3.org/2000/10/swap/string#greaterThan)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the string is greater than the object
when ordered according to Unicode(tm) code order.</p></div><div><h4>string:join</h4>(http://www.w3.org/2000/10/swap/string#join)<h5>schema</h5><p>subject: ($s_0 $s_1) where ($s_0_1 .. $s_0_n) where $s_0_i is stringable, $s_1 is stringable<br />object: $o is string OR variable</p></div><div><h4>string:length</h4>(http://www.w3.org/2000/10/swap/string#length)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is intable OR variable</p></div><div><h4>string:lessThan</h4>(http://www.w3.org/2000/10/swap/string#lessThan)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the string is less than the object
when ordered according to Unicode(tm) code order.</p></div><div><h4>string:lowerCase</h4>(http://www.w3.org/2000/10/swap/string#lowerCase)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable OR variable</p></div><div><h4>string:matches</h4>(http://www.w3.org/2000/10/swap/string#matches)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is regex</p><h5>comment</h5><p>The subject is a string;
the object is is a regular expression in the perl, python style.
It is true iff the string matches the regexp.</p></div><div><h4>string:notContainsRoughly</h4>(http://www.w3.org/2000/10/swap/string#notContainsRoughly)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p></div><div><h4>string:notEqualIgnoringCase</h4>(http://www.w3.org/2000/10/swap/string#notEqualIgnoringCase)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the subject string is the NOT same as object string
ignoring differences between upper and lower case.</p></div><div><h4>string:notGreaterThan</h4>(http://www.w3.org/2000/10/swap/string#notGreaterThan)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the string is NOT greater than the object
when ordered according to Unicode(tm) code order.</p></div><div><h4>string:notLessThan</h4>(http://www.w3.org/2000/10/swap/string#notLessThan)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the string is NOT less than the object
when ordered according to Unicode(tm) code order.</p></div><div><h4>string:notMatches</h4>(http://www.w3.org/2000/10/swap/string#notMatches)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is regex</p><h5>comment</h5><p>The subject string;
the object is is a regular expression in the perl, python style.
It is true iff the string does NOT match the regexp.</p></div><div><h4>string:replace</h4>(http://www.w3.org/2000/10/swap/string#replace)<h5>schema</h5><p>subject: ($s_0 $s_1 $s_2) where $s_0 is stringable, $s_1 is regex, $s_2 is stringable<br />object: $o is stringable OR variable</p><h5>comment</h5><p>A built-in for replacing characters or sub.
takes a list of 3 strings; the first is the
input data, the second the old and the third the new string.
The object is calculated as the replaced string.
For example, (\"fofof bar\", \"of\", \"baz\") string:replace \"fbazbaz bar\".</p></div><div><h4>string:replaceAll</h4>(http://www.w3.org/2000/10/swap/string#replaceAll)<h5>schema</h5><p>subject: ($s_0 $s_1 $s_2) where $s_0 is stringable, ($s_1_1 .. $s_1_n) where $s_1_i is regex, ($s_2_1 .. $s_2_n) where $s_2_i is stringable<br />object: $o is stringable OR variable</p></div><div><h4>string:scrape</h4>(http://www.w3.org/2000/10/swap/string#scrape)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is stringable, $s_1 is regex<br />object: $o is stringable OR variable</p><h5>comment</h5><p>The subject is a list of two strings. The second string is
a regular expression in the perl, python style.
It must contain one group (a part in parentheses).  If the first string in the list matches
the regular expression, then the object is calculated as being the
part of the first string which matches the group.</p></div><div><h4>string:scrapeAll</h4>(http://www.w3.org/2000/10/swap/string#scrapeAll)<h5>schema</h5><p>subject: ($s_0 $s_1) where $s_0 is stringable, $s_1 is regex<br />object: $o is list OR variable</p></div><div><h4>string:startsWith</h4>(http://www.w3.org/2000/10/swap/string#startsWith)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable</p><h5>comment</h5><p>True iff the subject string starts with the object string.</p></div><div><h4>string:substring</h4>(http://www.w3.org/2000/10/swap/string#substring)<h5>schema</h5><p>subject: ($s_0 $s_1 $s_2) where $s_0 is stringable, $s_1 is intable, $s_2 is intable OR variable<br />object: $o is stringable OR variable</p></div><div><h4>string:upperCase</h4>(http://www.w3.org/2000/10/swap/string#upperCase)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable OR variable</p></div></div><div><h2>crypto</h2>(http://www.w3.org/2000/10/swap/crypto#)<div><h4>crypto:sha</h4>(http://www.w3.org/2000/10/swap/crypto#sha)<h5>schema</h5><p>subject: $s is stringable<br />object: $o is stringable OR variable</p><h5>comment</h5><p>The object is a SHA-1 hash of the subject.</p></div></div><div><h2>graph</h2>(http://www.w3.org/2000/10/swap/graph#)<div><h4>graph:difference</h4>(http://www.w3.org/2000/10/swap/graph#difference)<h5>schema</h5><p>subject: ($s1 $s_2) where $s_i is formula<br />object: $o is formula OR variable</p></div><div><h4>graph:length</h4>(http://www.w3.org/2000/10/swap/graph#length)<h5>schema</h5><p>subject: $s is formula<br />object: $o is numberable OR variable</p></div><div><h4>graph:member</h4>(http://www.w3.org/2000/10/swap/graph#member)<h5>schema</h5><p>subject: $s is formula<br />object: $o is formula OR variable</p></div></div><div><h2>file</h2>(http://www.w3.org/2000/10/swap/file#)<div><h4>file:listFiles</h4>(http://www.w3.org/2000/10/swap/file#listFiles)<h5>schema</h5><p>subject: $s is iri<br />object: $o is formula OR variable</p></div></div></body></html>